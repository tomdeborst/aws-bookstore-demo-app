{"ast":null,"code":"\"use strict\"; // Extracted from https://github.com/facebook/react/blob/7bdf93b17a35a5d8fcf0ceae0bf48ed5e6b16688/src/renderers/shared/fiber/ReactFiberTreeReflection.js#L104-L228\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n\n  if (!alternate) {\n    return fiber;\n  } // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n\n\n  var a = fiber;\n  var b = alternate;\n\n  while (true) {\n    // eslint-disable-line\n    var parentA = a[\"return\"];\n    var parentB = parentA ? parentA.alternate : null;\n\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    } // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n\n\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          return fiber;\n        }\n\n        if (child === b) {\n          // We've determined that B is the current branch.\n          return alternate;\n        }\n\n        child = child.sibling;\n      } // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n\n\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (a[\"return\"] !== b[\"return\"]) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n\n        _child = _child.sibling;\n      }\n\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n\n          _child = _child.sibling;\n        }\n\n        if (!didFindChild) {\n          throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n        }\n      }\n    }\n  }\n\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  } // Otherwise B has to be current branch.\n\n\n  return alternate;\n}\n\nmodule.exports = findCurrentFiberUsingSlowPath; //# sourceMappingURL=findCurrentFiberUsingSlowPath.js.map","map":{"version":3,"sources":["../src/findCurrentFiberUsingSlowPath.js"],"names":["alternate","fiber","a","b","parentA","parentB","child","didFindChild","module"],"mappings":"cAAA;;AACA,SAAA,6BAAA,CAAA,KAAA,EAA8C;AAAA,MACpCA,SADoC,GACtBC,KADsB,CAAA,SAAA;;AAE5C,MAAI,CAAJ,SAAA,EAAgB;AACd,WAAA,KAAA;AAH0C,GAAA,CAK5C;AACA;AACA;;;AACA,MAAIC,CAAC,GAAL,KAAA;AACA,MAAIC,CAAC,GAAL,SAAA;;AACA,SAAA,IAAA,EAAa;AAAE;AACb,QAAMC,OAAO,GAAGF,CAAC,CAAjB,QAAiB,CAAjB;AACA,QAAMG,OAAO,GAAGD,OAAO,GAAGA,OAAO,CAAV,SAAA,GAAvB,IAAA;;AACA,QAAI,CAAA,OAAA,IAAY,CAAhB,OAAA,EAA0B;AACxB;AACA;AALS,KAAA,CAQX;AACA;AACA;;;AACA,QAAIA,OAAO,CAAPA,KAAAA,KAAkBC,OAAO,CAA7B,KAAA,EAAqC;AAAA,UAC7BC,KAD6B,GACnBF,OADmB,CAAA,KAAA;;AAEnC,aAAA,KAAA,EAAc;AACZ,YAAIE,KAAK,KAAT,CAAA,EAAiB;AACf;AACA,iBAAA,KAAA;AACD;;AACD,YAAIA,KAAK,KAAT,CAAA,EAAiB;AACf;AACA,iBAAA,SAAA;AACD;;AACDA,QAAAA,KAAK,GAAGA,KAAK,CAAbA,OAAAA;AAXiC,OAAA,CAanC;AACA;;;AACA,YAAM,IAAA,KAAA,CAAN,gDAAM,CAAN;AACD;;AAED,QAAIJ,CAAC,CAADA,QAAC,CAADA,KAAaC,CAAC,CAAlB,QAAkB,CAAlB,EAA2B;AACzB;AACA;AACA;AACA;AACAD,MAAAA,CAAC,GAADA,OAAAA;AACAC,MAAAA,CAAC,GAADA,OAAAA;AANF,KAAA,MAOO;AACL;AACA;AACA;AACA;AACA;AACA,UAAII,YAAY,GAAhB,KAAA;AANK,UAOCD,MAPD,GAOWF,OAPX,CAAA,KAAA;;AAQL,aAAA,MAAA,EAAc;AACZ,YAAIE,MAAK,KAAT,CAAA,EAAiB;AACfC,UAAAA,YAAY,GAAZA,IAAAA;AACAL,UAAAA,CAAC,GAADA,OAAAA;AACAC,UAAAA,CAAC,GAADA,OAAAA;AACA;AACD;;AACD,YAAIG,MAAK,KAAT,CAAA,EAAiB;AACfC,UAAAA,YAAY,GAAZA,IAAAA;AACAJ,UAAAA,CAAC,GAADA,OAAAA;AACAD,UAAAA,CAAC,GAADA,OAAAA;AACA;AACD;;AACDI,QAAAA,MAAK,GAAGA,MAAK,CAAbA,OAAAA;AACD;;AACD,UAAI,CAAJ,YAAA,EAAmB;AACjB;AACGA,QAAAA,MAFc,GAEJD,OAFI,CAAA,KAEdC;;AACH,eAAA,MAAA,EAAc;AACZ,cAAIA,MAAK,KAAT,CAAA,EAAiB;AACfC,YAAAA,YAAY,GAAZA,IAAAA;AACAL,YAAAA,CAAC,GAADA,OAAAA;AACAC,YAAAA,CAAC,GAADA,OAAAA;AACA;AACD;;AACD,cAAIG,MAAK,KAAT,CAAA,EAAiB;AACfC,YAAAA,YAAY,GAAZA,IAAAA;AACAJ,YAAAA,CAAC,GAADA,OAAAA;AACAD,YAAAA,CAAC,GAADA,OAAAA;AACA;AACD;;AACDI,UAAAA,MAAK,GAAGA,MAAK,CAAbA,OAAAA;AACD;;AACD,YAAI,CAAJ,YAAA,EAAmB;AACjB,gBAAM,IAAA,KAAA,CAAU,oEAAhB,+DAAM,CAAN;AAED;AACF;AACF;AACF;;AACD,MAAIJ,CAAC,CAADA,SAAAA,CAAAA,OAAAA,KAAJ,CAAA,EAA+B;AAC7B;AACA,WAAA,KAAA;AAhG0C,GAAA,CAkG5C;;;AACA,SAAA,SAAA;AACD;;AAEDM,MAAM,CAANA,OAAAA,GAAAA,6BAAAA,C","sourcesContent":["// Extracted from https://github.com/facebook/react/blob/7bdf93b17a35a5d8fcf0ceae0bf48ed5e6b16688/src/renderers/shared/fiber/ReactFiberTreeReflection.js#L104-L228\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  const { alternate } = fiber;\n  if (!alternate) {\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  let a = fiber;\n  let b = alternate;\n  while (true) { // eslint-disable-line\n    const parentA = a.return;\n    const parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      let { child } = parentA;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      let didFindChild = false;\n      let { child } = parentA;\n      while (child) {\n        if (child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        child = child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        ({ child } = parentB);\n        while (child) {\n          if (child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          child = child.sibling;\n        }\n        if (!didFindChild) {\n          throw new Error('Child was not found in either parent set. This indicates a bug '\n            + 'in React related to the return pointer. Please file an issue.');\n        }\n      }\n    }\n  }\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nmodule.exports = findCurrentFiberUsingSlowPath;\n"]},"metadata":{},"sourceType":"script"}