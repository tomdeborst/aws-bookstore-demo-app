{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.propsOfNode = propsOfNode;\nexports.childrenOfNode = childrenOfNode;\nexports.hasClassName = hasClassName;\nexports.treeForEach = treeForEach;\nexports.treeFilter = treeFilter;\nexports.findParentNode = findParentNode;\nexports.pathToNode = pathToNode;\nexports.parentsOfNode = parentsOfNode;\nexports.nodeHasId = nodeHasId;\nexports.nodeMatchesObjectProps = nodeMatchesObjectProps;\nexports.getTextFromNode = getTextFromNode;\nexports.getTextFromHostNodes = getTextFromHostNodes;\nexports.getHTMLFromHostNodes = getHTMLFromHostNodes;\n\nvar _object = require('object.assign');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _arrayPrototype = require('array.prototype.flat');\n\nvar _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);\n\nvar _object3 = require('object.entries');\n\nvar _object4 = _interopRequireDefault(_object3);\n\nvar _isSubset = require('is-subset');\n\nvar _isSubset2 = _interopRequireDefault(_isSubset);\n\nvar _functionPrototype = require('function.prototype.name');\n\nvar _functionPrototype2 = _interopRequireDefault(_functionPrototype);\n\nvar _isRegex = require('is-regex');\n\nvar _isRegex2 = _interopRequireDefault(_isRegex);\n\nvar _getAdapter = require('./getAdapter');\n\nvar _getAdapter2 = _interopRequireDefault(_getAdapter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction propsOfNode(node) {\n  return node && node.props || {};\n}\n\nfunction childrenOfNode(node) {\n  if (!node) return [];\n  var adapter = (0, _getAdapter2['default'])();\n  var adapterHasIsFragment = adapter.isFragment && typeof adapter.isFragment === 'function';\n  var renderedArray = Array.isArray(node.rendered) ? (0, _arrayPrototype2['default'])(node.rendered, 1) : [node.rendered]; // React adapters before 16 will not have isFragment\n\n  if (!adapterHasIsFragment) {\n    return renderedArray;\n  }\n\n  return (0, _arrayPrototype2['default'])(renderedArray.map(function (currentChild) {\n    // If the node is a Fragment, we want to return its children, not the fragment itself\n    if (adapter.isFragment(currentChild)) {\n      return childrenOfNode(currentChild);\n    }\n\n    return currentChild;\n  }), 1);\n}\n\nfunction hasClassName(node, className) {\n  var classes = propsOfNode(node).className || '';\n  classes = String(classes).replace(/\\s/g, ' ');\n  if ((0, _isRegex2['default'])(className)) return className.test(classes);\n  return (' ' + String(classes) + ' ').indexOf(' ' + String(className) + ' ') > -1;\n}\n\nfunction treeForEach(tree, fn) {\n  if (tree) {\n    fn(tree);\n  }\n\n  childrenOfNode(tree).forEach(function (node) {\n    return treeForEach(node, fn);\n  });\n}\n\nfunction treeFilter(tree, fn) {\n  var results = [];\n  treeForEach(tree, function (node) {\n    if (fn(node)) {\n      results.push(node);\n    }\n  });\n  return results;\n}\n/**\n * To support sibling selectors we need to be able to find\n * the siblings of a node. The easiest way to do that is find\n * the parent of the node and access its children.\n *\n * This would be unneeded if the RST spec included sibling pointers\n * such as node.nextSibling and node.prevSibling\n * @param {*} root\n * @param {*} targetNode\n */\n\n\nfunction findParentNode(root, targetNode) {\n  var results = treeFilter(root, function (node) {\n    if (!node.rendered) {\n      return false;\n    }\n\n    return childrenOfNode(node).indexOf(targetNode) !== -1;\n  });\n  return results[0] || null;\n}\n\nfunction pathFilter(path, fn) {\n  return path.filter(function (tree) {\n    return treeFilter(tree, fn).length !== 0;\n  });\n}\n\nfunction pathToNode(node, root) {\n  var queue = [root];\n  var path = [];\n\n  var hasNode = function hasNode(testNode) {\n    return node === testNode;\n  };\n\n  while (queue.length) {\n    var current = queue.pop();\n    var children = childrenOfNode(current);\n    if (current === node) return pathFilter(path, hasNode);\n    path.push(current);\n\n    if (children.length === 0) {\n      // leaf node. if it isn't the node we are looking for, we pop.\n      path.pop();\n    }\n\n    queue.push.apply(queue, _toConsumableArray(children));\n  }\n\n  return null;\n}\n\nfunction parentsOfNode(node, root) {\n  return (pathToNode(node, root) || []).reverse();\n}\n\nfunction nodeHasId(node, id) {\n  return propsOfNode(node).id === id;\n}\n\nvar CAN_NEVER_MATCH = {};\n\nfunction replaceUndefined(v) {\n  return typeof v !== 'undefined' ? v : CAN_NEVER_MATCH;\n}\n\nfunction replaceUndefinedValues(obj) {\n  return (0, _object4['default'])(obj).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        k = _ref2[0],\n        v = _ref2[1];\n\n    return (0, _object2['default'])({}, acc, _defineProperty({}, k, replaceUndefined(v)));\n  }, {});\n}\n\nfunction nodeMatchesObjectProps(node, props) {\n  return (0, _isSubset2['default'])(propsOfNode(node), replaceUndefinedValues(props));\n}\n\nfunction getTextFromHostNode(hostNode) {\n  if (typeof hostNode === 'string') {\n    return String(hostNode || '');\n  }\n\n  if (!hostNode) {\n    return '';\n  }\n\n  return hostNode.textContent || '';\n}\n\nfunction getTextFromRSTNode(node, _ref3) {\n  var getCustom = _ref3.getCustom,\n      handleHostNodes = _ref3.handleHostNodes,\n      recurse = _ref3.recurse,\n      _ref3$nullRenderRetur = _ref3.nullRenderReturnsNull,\n      nullRenderReturnsNull = _ref3$nullRenderRetur === undefined ? false : _ref3$nullRenderRetur;\n\n  if (node == null) {\n    return '';\n  }\n\n  if (typeof node === 'string' || typeof node === 'number') {\n    return String(node);\n  }\n\n  if (getCustom && node.type && typeof node.type === 'function') {\n    return getCustom(node);\n  }\n\n  if (handleHostNodes && node.nodeType === 'host') {\n    return handleHostNodes(node);\n  }\n\n  if (node.rendered == null && nullRenderReturnsNull) {\n    return null;\n  }\n\n  return childrenOfNode(node).map(recurse).join('');\n}\n\nfunction getTextFromNode(node) {\n  return getTextFromRSTNode(node, {\n    recurse: getTextFromNode,\n    getCustom: function () {\n      function getCustom(_ref4) {\n        var type = _ref4.type;\n        return '<' + String(type.displayName || (0, _functionPrototype2['default'])(type)) + ' />';\n      }\n\n      return getCustom;\n    }()\n  });\n}\n\nfunction getTextFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse: function () {\n      function recurse(item) {\n        return getTextFromHostNodes(item, adapter);\n      }\n\n      return recurse;\n    }(),\n    handleHostNodes: function () {\n      function handleHostNodes(item) {\n        var nodes = [].concat(adapter.nodeToHostNode(item, true));\n        return nodes.map(getTextFromHostNode).join('');\n      }\n\n      return handleHostNodes;\n    }()\n  });\n}\n\nfunction getHTMLFromHostNode(hostNode) {\n  if (hostNode == null) {\n    return null;\n  }\n\n  return hostNode.outerHTML.replace(/\\sdata-(reactid|reactroot)+=\"([^\"]*)+\"/g, '');\n}\n\nfunction getHTMLFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse: function () {\n      function recurse(item) {\n        return getHTMLFromHostNodes(item, adapter);\n      }\n\n      return recurse;\n    }(),\n    handleHostNodes: function () {\n      function handleHostNodes(item) {\n        var nodes = [].concat(adapter.nodeToHostNode(item, true));\n        return nodes.map(getHTMLFromHostNode).join('');\n      }\n\n      return handleHostNodes;\n    }(),\n    nullRenderReturnsNull: true\n  });\n} //# sourceMappingURL=RSTTraversal.js.map","map":{"version":3,"sources":["../src/RSTTraversal.js"],"names":["propsOfNode","node","childrenOfNode","adapter","adapterHasIsFragment","renderedArray","Array","hasClassName","classes","String","className","treeForEach","fn","treeFilter","results","findParentNode","pathToNode","queue","path","hasNode","current","children","pathFilter","parentsOfNode","nodeHasId","CAN_NEVER_MATCH","k","v","replaceUndefined","nodeMatchesObjectProps","replaceUndefinedValues","hostNode","getCustom","handleHostNodes","recurse","nullRenderReturnsNull","getTextFromNode","type","getTextFromHostNodes","nodes","getHTMLFromHostNodes"],"mappings":"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","sourcesContent":["import flat from 'array.prototype.flat';\nimport entries from 'object.entries';\nimport isSubset from 'is-subset';\nimport functionName from 'function.prototype.name';\nimport isRegex from 'is-regex';\nimport getAdapter from './getAdapter';\n\nexport function propsOfNode(node) {\n  return (node && node.props) || {};\n}\n\nexport function childrenOfNode(node) {\n  if (!node) return [];\n\n  const adapter = getAdapter();\n  const adapterHasIsFragment = adapter.isFragment && typeof adapter.isFragment === 'function';\n\n  const renderedArray = Array.isArray(node.rendered) ? flat(node.rendered, 1) : [node.rendered];\n\n  // React adapters before 16 will not have isFragment\n  if (!adapterHasIsFragment) {\n    return renderedArray;\n  }\n\n  return flat(renderedArray.map((currentChild) => {\n    // If the node is a Fragment, we want to return its children, not the fragment itself\n    if (adapter.isFragment(currentChild)) {\n      return childrenOfNode(currentChild);\n    }\n\n    return currentChild;\n  }), 1);\n}\n\nexport function hasClassName(node, className) {\n  let classes = propsOfNode(node).className || '';\n  classes = String(classes).replace(/\\s/g, ' ');\n  if (isRegex(className)) return className.test(classes);\n  return ` ${classes} `.indexOf(` ${className} `) > -1;\n}\n\nexport function treeForEach(tree, fn) {\n  if (tree) {\n    fn(tree);\n  }\n  childrenOfNode(tree).forEach((node) => treeForEach(node, fn));\n}\n\nexport function treeFilter(tree, fn) {\n  const results = [];\n  treeForEach(tree, (node) => {\n    if (fn(node)) {\n      results.push(node);\n    }\n  });\n  return results;\n}\n\n/**\n * To support sibling selectors we need to be able to find\n * the siblings of a node. The easiest way to do that is find\n * the parent of the node and access its children.\n *\n * This would be unneeded if the RST spec included sibling pointers\n * such as node.nextSibling and node.prevSibling\n * @param {*} root\n * @param {*} targetNode\n */\nexport function findParentNode(root, targetNode) {\n  const results = treeFilter(\n    root,\n    (node) => {\n      if (!node.rendered) {\n        return false;\n      }\n\n      return childrenOfNode(node).indexOf(targetNode) !== -1;\n    },\n  );\n  return results[0] || null;\n}\n\nfunction pathFilter(path, fn) {\n  return path.filter((tree) => treeFilter(tree, fn).length !== 0);\n}\n\nexport function pathToNode(node, root) {\n  const queue = [root];\n  const path = [];\n\n  const hasNode = (testNode) => node === testNode;\n\n  while (queue.length) {\n    const current = queue.pop();\n    const children = childrenOfNode(current);\n    if (current === node) return pathFilter(path, hasNode);\n\n    path.push(current);\n\n    if (children.length === 0) {\n      // leaf node. if it isn't the node we are looking for, we pop.\n      path.pop();\n    }\n    queue.push(...children);\n  }\n\n  return null;\n}\n\nexport function parentsOfNode(node, root) {\n  return (pathToNode(node, root) || []).reverse();\n}\n\nexport function nodeHasId(node, id) {\n  return propsOfNode(node).id === id;\n}\n\nconst CAN_NEVER_MATCH = {};\nfunction replaceUndefined(v) {\n  return typeof v !== 'undefined' ? v : CAN_NEVER_MATCH;\n}\nfunction replaceUndefinedValues(obj) {\n  return entries(obj)\n    .reduce((acc, [k, v]) => ({ ...acc, [k]: replaceUndefined(v) }), {});\n}\n\nexport function nodeMatchesObjectProps(node, props) {\n  return isSubset(propsOfNode(node), replaceUndefinedValues(props));\n}\n\nfunction getTextFromHostNode(hostNode) {\n  if (typeof hostNode === 'string') {\n    return String(hostNode || '');\n  }\n  if (!hostNode) {\n    return '';\n  }\n  return hostNode.textContent || '';\n}\n\nfunction getTextFromRSTNode(node, {\n  getCustom,\n  handleHostNodes,\n  recurse,\n  nullRenderReturnsNull = false,\n}) {\n  if (node == null) {\n    return '';\n  }\n\n  if (typeof node === 'string' || typeof node === 'number') {\n    return String(node);\n  }\n\n  if (getCustom && node.type && typeof node.type === 'function') {\n    return getCustom(node);\n  }\n\n  if (handleHostNodes && node.nodeType === 'host') {\n    return handleHostNodes(node);\n  }\n  if (node.rendered == null && nullRenderReturnsNull) {\n    return null;\n  }\n  return childrenOfNode(node).map(recurse).join('');\n}\n\nexport function getTextFromNode(node) {\n  return getTextFromRSTNode(node, {\n    recurse: getTextFromNode,\n    getCustom({ type }) {\n      return `<${type.displayName || functionName(type)} />`;\n    },\n  });\n}\n\nexport function getTextFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse(item) {\n      return getTextFromHostNodes(item, adapter);\n    },\n    handleHostNodes(item) {\n      const nodes = [].concat(adapter.nodeToHostNode(item, true));\n      return nodes.map(getTextFromHostNode).join('');\n    },\n  });\n}\n\nfunction getHTMLFromHostNode(hostNode) {\n  if (hostNode == null) {\n    return null;\n  }\n  return hostNode.outerHTML.replace(/\\sdata-(reactid|reactroot)+=\"([^\"]*)+\"/g, '');\n}\n\nexport function getHTMLFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse(item) {\n      return getHTMLFromHostNodes(item, adapter);\n    },\n    handleHostNodes(item) {\n      const nodes = [].concat(adapter.nodeToHostNode(item, true));\n      return nodes.map(getHTMLFromHostNode).join('');\n    },\n    nullRenderReturnsNull: true,\n  });\n}\n"]},"metadata":{},"sourceType":"script"}