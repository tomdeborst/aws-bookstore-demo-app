{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.buildPredicate = buildPredicate;\nexports.reduceTreeBySelector = reduceTreeBySelector;\nexports.reduceTreesBySelector = reduceTreesBySelector;\n\nvar _rstSelectorParser = require('rst-selector-parser');\n\nvar _object = require('object.values');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _arrayPrototype = require('array.prototype.flat');\n\nvar _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);\n\nvar _objectIs = require('object-is');\n\nvar _objectIs2 = _interopRequireDefault(_objectIs);\n\nvar _has = require('has');\n\nvar _has2 = _interopRequireDefault(_has);\n\nvar _byConstructor = require('html-element-map/byConstructor');\n\nvar _byConstructor2 = _interopRequireDefault(_byConstructor);\n\nvar _RSTTraversal = require('./RSTTraversal');\n\nvar _Utils = require('./Utils');\n\nvar _getAdapter = require('./getAdapter');\n\nvar _getAdapter2 = _interopRequireDefault(_getAdapter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n} // our CSS selector parser instance\n\n\nvar parser = (0, _rstSelectorParser.createParser)(); // Combinators that allow you to chance selectors\n\nvar CHILD = 'childCombinator';\nvar ADJACENT_SIBLING = 'adjacentSiblingCombinator';\nvar GENERAL_SIBLING = 'generalSiblingCombinator';\nvar DESCENDANT = 'descendantCombinator'; // Selectors for targeting elements\n\nvar SELECTOR = 'selector';\nvar TYPE_SELECTOR = 'typeSelector';\nvar CLASS_SELECTOR = 'classSelector';\nvar ID_SELECTOR = 'idSelector';\nvar UNIVERSAL_SELECTOR = 'universalSelector';\nvar ATTRIBUTE_PRESENCE = 'attributePresenceSelector';\nvar ATTRIBUTE_VALUE = 'attributeValueSelector'; // @TODO we dont support these, throw if they are used\n\nvar PSEUDO_CLASS = 'pseudoClassSelector';\nvar PSEUDO_ELEMENT = 'pseudoElementSelector';\nvar EXACT_ATTRIBUTE_OPERATOR = '=';\nvar WHITELIST_ATTRIBUTE_OPERATOR = '~=';\nvar HYPHENATED_ATTRIBUTE_OPERATOR = '|=';\nvar PREFIX_ATTRIBUTE_OPERATOR = '^=';\nvar SUFFIX_ATTRIBUTE_OPERATOR = '$=';\nvar SUBSTRING_ATTRIBUTE_OPERATOR = '*=';\n\nfunction unique(arr) {\n  return [].concat(_toConsumableArray(new Set(arr)));\n}\n/**\n * Calls reduce on a array of nodes with the passed\n * function, returning only unique results.\n * @param {Function} fn\n * @param {Array<Node>} nodes\n */\n\n\nfunction uniqueReduce(fn, nodes) {\n  return unique(nodes.reduce(fn, []));\n}\n/**\n * Takes a CSS selector and returns a set of tokens parsed\n * by scalpel.\n * @param {String} selector\n */\n\n\nfunction safelyGenerateTokens(selector) {\n  try {\n    return parser.parse(selector);\n  } catch (err) {\n    throw new Error('Failed to parse selector: ' + String(selector));\n  }\n}\n\nfunction matchAttributeSelector(node, token) {\n  var operator = token.operator,\n      value = token.value,\n      name = token.name;\n  var nodeProps = (0, _Utils.propsOfNode)(node);\n  var descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);\n\n  if (descriptor && descriptor.get) {\n    return false;\n  }\n\n  var nodePropValue = nodeProps[name];\n\n  if (typeof nodePropValue === 'undefined') {\n    return false;\n  }\n\n  if (token.type === ATTRIBUTE_PRESENCE) {\n    return (0, _has2['default'])(nodeProps, token.name);\n  } // Only the exact value operator (\"=\") can match non-strings\n\n\n  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {\n    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {\n      return false;\n    }\n  }\n\n  switch (operator) {\n    /**\n     * Represents an element with the att attribute whose value is exactly \"val\".\n     * @example\n     * [attr=\"val\"] matches attr=\"val\"\n     */\n    case EXACT_ATTRIBUTE_OPERATOR:\n      return (0, _objectIs2['default'])(nodePropValue, value);\n\n    /**\n     * Represents an element with the att attribute whose value is a whitespace-separated\n     * list of words, one of which is exactly\n     * @example\n     *  [rel~=\"copyright\"] matches rel=\"copyright other\"\n     */\n\n    case WHITELIST_ATTRIBUTE_OPERATOR:\n      return nodePropValue.split(' ').indexOf(value) !== -1;\n\n    /**\n     * Represents an element with the att attribute, its value either being exactly the\n     * value or beginning with the value immediately followed by \"-\"\n     * @example\n     * [hreflang|=\"en\"] matches hreflang=\"en-US\"\n     */\n\n    case HYPHENATED_ATTRIBUTE_OPERATOR:\n      return nodePropValue === value || nodePropValue.startsWith(String(value) + '-');\n\n    /**\n     * Represents an element with the att attribute whose value begins with the prefix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type^=\"image\"] matches type=\"imageobject\"\n     */\n\n    case PREFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(0, value.length) === value;\n\n    /**\n     * Represents an element with the att attribute whose value ends with the suffix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type$=\"image\"] matches type=\"imageobject\"\n     */\n\n    case SUFFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(-value.length) === value;\n\n    /**\n     * Represents an element with the att attribute whose value contains at least one\n     * instance of the value. If value is the empty string then the\n     * selector does not represent anything.\n     * @example\n     * [title*=\"hello\"] matches title=\"well hello there\"\n     */\n\n    case SUBSTRING_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.indexOf(value) !== -1;\n\n    default:\n      throw new Error('Enzyme::Selector: Unknown attribute selector operator \"' + String(operator) + '\"');\n  }\n}\n\nfunction matchPseudoSelector(node, token, root) {\n  var name = token.name,\n      parameters = token.parameters;\n\n  if (name === 'not') {\n    // eslint-disable-next-line no-use-before-define\n    return parameters.every(function (selector) {\n      return reduceTreeBySelector(selector, node).length === 0;\n    });\n  }\n\n  if (name === 'empty') {\n    return (0, _RSTTraversal.treeFilter)(node, function (n) {\n      return n !== node;\n    }).length === 0;\n  }\n\n  if (name === 'first-child') {\n    var _findParentNode = (0, _RSTTraversal.findParentNode)(root, node),\n        rendered = _findParentNode.rendered;\n\n    var _rendered = _slicedToArray(rendered, 1),\n        firstChild = _rendered[0];\n\n    return firstChild === node;\n  }\n\n  if (name === 'last-child') {\n    var _findParentNode2 = (0, _RSTTraversal.findParentNode)(root, node),\n        _rendered2 = _findParentNode2.rendered;\n\n    return _rendered2[_rendered2.length - 1] === node;\n  }\n\n  if (name === 'focus') {\n    if (typeof document === 'undefined') {\n      throw new Error('Enzyme::Selector does not support the \":focus\" pseudo-element without a global `document`.');\n    }\n\n    var adapter = (0, _getAdapter2['default'])();\n    /* eslint-env browser */\n\n    return document.activeElement && adapter.nodeToHostNode(node) === document.activeElement;\n  }\n\n  throw new TypeError('Enzyme::Selector does not support the \"' + String(token.name) + '\" pseudo-element or pseudo-class selectors.');\n}\n/**\n * Takes a node and a token and determines if the node\n * matches the predicate defined by the token.\n * @param {Node} node\n * @param {Token} token\n */\n\n\nfunction nodeMatchesToken(node, token, root) {\n  if (node === null || typeof node === 'string') {\n    return false;\n  }\n\n  switch (token.type) {\n    /**\n     * Match every node\n     * @example '*' matches every node\n     */\n    case UNIVERSAL_SELECTOR:\n      return true;\n\n    /**\n     * Match against the className prop\n     * @example '.active' matches <div className='active' />\n     */\n\n    case CLASS_SELECTOR:\n      return (0, _RSTTraversal.hasClassName)(node, token.name);\n\n    /**\n     * Simple type matching\n     * @example 'div' matches <div />\n     */\n\n    case TYPE_SELECTOR:\n      return (0, _Utils.nodeHasType)(node, token.name);\n\n    /**\n     * Match against the `id` prop\n     * @example '#nav' matches <ul id=\"nav\" />\n     */\n\n    case ID_SELECTOR:\n      return (0, _RSTTraversal.nodeHasId)(node, token.name);\n\n    /**\n     * Matches if an attribute is present, regardless\n     * of its value\n     * @example '[disabled]' matches <a disabled />\n     */\n\n    case ATTRIBUTE_PRESENCE:\n      return matchAttributeSelector(node, token);\n\n    /**\n     * Matches if an attribute is present with the\n     * provided value\n     * @example '[data-foo=foo]' matches <div data-foo=\"foo\" />\n     */\n\n    case ATTRIBUTE_VALUE:\n      return matchAttributeSelector(node, token);\n\n    case PSEUDO_ELEMENT:\n    case PSEUDO_CLASS:\n      return matchPseudoSelector(node, token, root);\n\n    default:\n      throw new Error('Unknown token type: ' + String(token.type));\n  }\n}\n/**\n * Returns a predicate function that checks if a\n * node matches every token in the body of a selector\n * token.\n * @param {Token} token\n */\n\n\nfunction buildPredicateFromToken(token, root) {\n  return function (node) {\n    return token.body.every(function (bodyToken) {\n      return nodeMatchesToken(node, bodyToken, root);\n    });\n  };\n}\n/**\n * Returns whether a parsed selector is a complex selector, which\n * is defined as a selector that contains combinators.\n * @param {Array<Token>} tokens\n */\n\n\nfunction isComplexSelector(tokens) {\n  return tokens.some(function (token) {\n    return token.type !== SELECTOR;\n  });\n}\n/**\n * Takes a component constructor, object, or string representing\n * a simple selector and returns a predicate function that can\n * be applied to a single node.\n * @param {EnzymeSelector} selector\n */\n\n\nfunction buildPredicate(selector) {\n  // If the selector is a string, parse it as a simple CSS selector\n  if (typeof selector === 'string') {\n    var tokens = safelyGenerateTokens(selector);\n\n    if (isComplexSelector(tokens)) {\n      throw new TypeError('This method does not support complex CSS selectors');\n    } // Simple selectors only have a single selector token\n\n\n    return buildPredicateFromToken(tokens[0]);\n  } // If the selector is an element type, check if the node's type matches\n\n\n  var adapter = (0, _getAdapter2['default'])();\n  var isElementType = adapter.isValidElementType ? adapter.isValidElementType(selector) : typeof selector === 'function';\n\n  if (isElementType) {\n    return function (node) {\n      return adapter.matchesElementType(node, selector);\n    };\n  } // If the selector is an non-empty object, treat the keys/values as props\n\n\n  if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {\n    if (!Array.isArray(selector) && selector !== null && Object.keys(selector).length > 0) {\n      var hasUndefinedValues = (0, _object2['default'])(selector).some(function (value) {\n        return typeof value === 'undefined';\n      });\n\n      if (hasUndefinedValues) {\n        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');\n      }\n\n      return function (node) {\n        return (0, _RSTTraversal.nodeMatchesObjectProps)(node, selector);\n      };\n    }\n\n    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');\n  }\n\n  throw new TypeError('Enzyme::Selector expects a string, object, or valid element type (Component Constructor)');\n}\n/**\n * Matches only nodes which are adjacent siblings (direct next sibling)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\n\n\nfunction matchAdjacentSiblings(nodes, predicate, root) {\n  return nodes.reduce(function (matches, node) {\n    var parent = (0, _RSTTraversal.findParentNode)(root, node); // If there's no parent, there's no siblings\n\n    if (!parent) {\n      return matches;\n    }\n\n    var parentChildren = (0, _RSTTraversal.childrenOfNode)(parent);\n    var nodeIndex = parentChildren.indexOf(node);\n    var adjacentSibling = parentChildren[nodeIndex + 1]; // No sibling\n\n    if (!adjacentSibling) {\n      return matches;\n    }\n\n    if (predicate(adjacentSibling)) {\n      matches.push(adjacentSibling);\n    }\n\n    return matches;\n  }, []);\n}\n/**\n * Matches only nodes which are general siblings (any sibling *after*)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\n\n\nfunction matchGeneralSibling(nodes, predicate, root) {\n  return uniqueReduce(function (matches, node) {\n    var parent = (0, _RSTTraversal.findParentNode)(root, node);\n\n    if (!parent) {\n      return matches;\n    }\n\n    var parentChildren = (0, _RSTTraversal.childrenOfNode)(parent);\n    var nodeIndex = parentChildren.indexOf(node);\n    var youngerSiblings = parentChildren.slice(nodeIndex + 1);\n    return matches.concat(youngerSiblings.filter(predicate));\n  }, nodes);\n}\n/**\n * Matches only nodes which are direct children (not grandchildren, etc.)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\n\n\nfunction matchDirectChild(nodes, predicate) {\n  return uniqueReduce(function (matches, node) {\n    return matches.concat((0, _RSTTraversal.childrenOfNode)(node).filter(predicate));\n  }, nodes);\n}\n/**\n * Matches all descendant nodes against a predicate,\n * returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\n\n\nfunction matchDescendant(nodes, predicate) {\n  return uniqueReduce(function (matches, node) {\n    return matches.concat((0, _RSTTraversal.treeFilter)(node, predicate));\n  }, (0, _arrayPrototype2['default'])(nodes.map(_RSTTraversal.childrenOfNode)));\n}\n/**\n * Takes an RST and reduces it to a set of nodes matching\n * the selector. The selector can be a simple selector, which\n * is handled by `buildPredicate`, or a complex CSS selector which\n * reduceTreeBySelector parses and reduces the tree based on the combinators.\n *\n * @param {EnzymeSelector} selector\n * @param {RSTNode} root\n */\n\n\nfunction reduceTreeBySelector(selector, root) {\n  if (typeof selector !== 'string') {\n    var elements = (0, _byConstructor2['default'])(selector);\n\n    if (elements.length > 0) {\n      return (0, _arrayPrototype2['default'])(elements.map(function (x) {\n        return reduceTreeBySelector(x.tag, root);\n      })); // when https://github.com/aweary/rst-selector-parser/issues/15 is resolved\n      // const htmlTagNames = elements.map(x => x.tag).join(', ');\n      // return reduceTreeBySelector(htmlTagNames, root);\n    }\n  }\n\n  if (typeof selector === 'function' || (typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {\n    return (0, _RSTTraversal.treeFilter)(root, buildPredicate(selector));\n  }\n\n  var results = [];\n\n  if (typeof selector === 'string') {\n    var tokens = safelyGenerateTokens(selector);\n    var index = 0;\n\n    while (index < tokens.length) {\n      var token = tokens[index];\n      /**\n       * There are two types of tokens in a CSS selector:\n       *\n       * 1. Selector tokens. These target nodes directly, like\n       *    type or attribute selectors. These are easy to apply\n       *    because we can traverse the tree and return only\n       *    the nodes that match the predicate.\n       *\n       * 2. Combinator tokens. These tokens chain together\n       *    selector nodes. For example > for children, or +\n       *    for adjacent siblings. These are harder to match\n       *    as we have to track where in the tree we are\n       *    to determine if a selector node applies or not.\n       */\n\n      if (token.type === SELECTOR) {\n        var predicate = buildPredicateFromToken(token, root);\n        results = results.concat((0, _RSTTraversal.treeFilter)(root, predicate));\n      } else {\n        // We can assume there always all previously matched tokens since selectors\n        // cannot start with combinators.\n        var type = token.type; // We assume the next token is a selector, so move the index\n        // forward and build the predicate.\n\n        index += 1;\n\n        var _predicate = buildPredicateFromToken(tokens[index], root); // We match against only the nodes which have already been matched,\n        // since a combinator is meant to refine a previous selector.\n\n\n        switch (type) {\n          // The + combinator\n          case ADJACENT_SIBLING:\n            results = matchAdjacentSiblings(results, _predicate, root);\n            break;\n          // The ~ combinator\n\n          case GENERAL_SIBLING:\n            results = matchGeneralSibling(results, _predicate, root);\n            break;\n          // The > combinator\n\n          case CHILD:\n            results = matchDirectChild(results, _predicate);\n            break;\n          // The ' ' (whitespace) combinator\n\n          case DESCENDANT:\n            {\n              results = matchDescendant(results, _predicate);\n              break;\n            }\n\n          default:\n            throw new Error('Unknown combinator selector: ' + String(type));\n        }\n      }\n\n      index += 1;\n    }\n  } else {\n    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');\n  }\n\n  return results;\n}\n\nfunction reduceTreesBySelector(selector, roots) {\n  var results = roots.map(function (n) {\n    return reduceTreeBySelector(selector, n);\n  });\n  return unique((0, _arrayPrototype2['default'])(results, 1));\n} //# sourceMappingURL=selectors.js.map","map":{"version":3,"sources":["../src/selectors.js"],"names":["parser","CHILD","ADJACENT_SIBLING","GENERAL_SIBLING","DESCENDANT","SELECTOR","TYPE_SELECTOR","CLASS_SELECTOR","ID_SELECTOR","UNIVERSAL_SELECTOR","ATTRIBUTE_PRESENCE","ATTRIBUTE_VALUE","PSEUDO_CLASS","PSEUDO_ELEMENT","EXACT_ATTRIBUTE_OPERATOR","WHITELIST_ATTRIBUTE_OPERATOR","HYPHENATED_ATTRIBUTE_OPERATOR","PREFIX_ATTRIBUTE_OPERATOR","SUFFIX_ATTRIBUTE_OPERATOR","SUBSTRING_ATTRIBUTE_OPERATOR","unique","nodes","operator","value","name","token","nodeProps","descriptor","Object","nodePropValue","parameters","reduceTreeBySelector","n","rendered","firstChild","adapter","document","node","matchAttributeSelector","matchPseudoSelector","nodeMatchesToken","buildPredicate","tokens","safelyGenerateTokens","isComplexSelector","buildPredicateFromToken","isElementType","Array","selector","hasUndefinedValues","parent","parentChildren","nodeIndex","adjacentSibling","predicate","matches","youngerSiblings","childrenOfNode","elements","x","results","index","type","matchAdjacentSiblings","matchGeneralSibling","matchDirectChild","matchDescendant","reduceTreesBySelector"],"mappings":"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","sourcesContent":["import { createParser } from 'rst-selector-parser';\nimport values from 'object.values';\nimport flat from 'array.prototype.flat';\nimport is from 'object-is';\nimport has from 'has';\nimport elementsByConstructor from 'html-element-map/byConstructor';\nimport {\n  treeFilter,\n  nodeHasId,\n  findParentNode,\n  nodeMatchesObjectProps,\n  childrenOfNode,\n  hasClassName,\n} from './RSTTraversal';\nimport { nodeHasType, propsOfNode } from './Utils';\nimport getAdapter from './getAdapter';\n// our CSS selector parser instance\nconst parser = createParser();\n\n// Combinators that allow you to chance selectors\nconst CHILD = 'childCombinator';\nconst ADJACENT_SIBLING = 'adjacentSiblingCombinator';\nconst GENERAL_SIBLING = 'generalSiblingCombinator';\nconst DESCENDANT = 'descendantCombinator';\n\n// Selectors for targeting elements\nconst SELECTOR = 'selector';\nconst TYPE_SELECTOR = 'typeSelector';\nconst CLASS_SELECTOR = 'classSelector';\nconst ID_SELECTOR = 'idSelector';\nconst UNIVERSAL_SELECTOR = 'universalSelector';\nconst ATTRIBUTE_PRESENCE = 'attributePresenceSelector';\nconst ATTRIBUTE_VALUE = 'attributeValueSelector';\n// @TODO we dont support these, throw if they are used\nconst PSEUDO_CLASS = 'pseudoClassSelector';\nconst PSEUDO_ELEMENT = 'pseudoElementSelector';\n\nconst EXACT_ATTRIBUTE_OPERATOR = '=';\nconst WHITELIST_ATTRIBUTE_OPERATOR = '~=';\nconst HYPHENATED_ATTRIBUTE_OPERATOR = '|=';\nconst PREFIX_ATTRIBUTE_OPERATOR = '^=';\nconst SUFFIX_ATTRIBUTE_OPERATOR = '$=';\nconst SUBSTRING_ATTRIBUTE_OPERATOR = '*=';\n\nfunction unique(arr) {\n  return [...new Set(arr)];\n}\n\n/**\n * Calls reduce on a array of nodes with the passed\n * function, returning only unique results.\n * @param {Function} fn\n * @param {Array<Node>} nodes\n */\nfunction uniqueReduce(fn, nodes) {\n  return unique(nodes.reduce(fn, []));\n}\n\n/**\n * Takes a CSS selector and returns a set of tokens parsed\n * by scalpel.\n * @param {String} selector\n */\nfunction safelyGenerateTokens(selector) {\n  try {\n    return parser.parse(selector);\n  } catch (err) {\n    throw new Error(`Failed to parse selector: ${selector}`);\n  }\n}\n\nfunction matchAttributeSelector(node, token) {\n  const { operator, value, name } = token;\n  const nodeProps = propsOfNode(node);\n  const descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);\n  if (descriptor && descriptor.get) {\n    return false;\n  }\n  const nodePropValue = nodeProps[name];\n  if (typeof nodePropValue === 'undefined') {\n    return false;\n  }\n  if (token.type === ATTRIBUTE_PRESENCE) {\n    return has(nodeProps, token.name);\n  }\n  // Only the exact value operator (\"=\") can match non-strings\n  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {\n    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {\n      return false;\n    }\n  }\n  switch (operator) {\n    /**\n     * Represents an element with the att attribute whose value is exactly \"val\".\n     * @example\n     * [attr=\"val\"] matches attr=\"val\"\n     */\n    case EXACT_ATTRIBUTE_OPERATOR:\n      return is(nodePropValue, value);\n    /**\n     * Represents an element with the att attribute whose value is a whitespace-separated\n     * list of words, one of which is exactly\n     * @example\n     *  [rel~=\"copyright\"] matches rel=\"copyright other\"\n     */\n    case WHITELIST_ATTRIBUTE_OPERATOR:\n      return nodePropValue.split(' ').indexOf(value) !== -1;\n    /**\n     * Represents an element with the att attribute, its value either being exactly the\n     * value or beginning with the value immediately followed by \"-\"\n     * @example\n     * [hreflang|=\"en\"] matches hreflang=\"en-US\"\n     */\n    case HYPHENATED_ATTRIBUTE_OPERATOR:\n      return nodePropValue === value || nodePropValue.startsWith(`${value}-`);\n    /**\n     * Represents an element with the att attribute whose value begins with the prefix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type^=\"image\"] matches type=\"imageobject\"\n     */\n    case PREFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(0, value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value ends with the suffix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type$=\"image\"] matches type=\"imageobject\"\n     */\n    case SUFFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(-value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value contains at least one\n     * instance of the value. If value is the empty string then the\n     * selector does not represent anything.\n     * @example\n     * [title*=\"hello\"] matches title=\"well hello there\"\n     */\n    case SUBSTRING_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.indexOf(value) !== -1;\n    default:\n      throw new Error(`Enzyme::Selector: Unknown attribute selector operator \"${operator}\"`);\n  }\n}\n\n\nfunction matchPseudoSelector(node, token, root) {\n  const { name, parameters } = token;\n  if (name === 'not') {\n    // eslint-disable-next-line no-use-before-define\n    return parameters.every((selector) => reduceTreeBySelector(selector, node).length === 0);\n  }\n  if (name === 'empty') {\n    return treeFilter(node, (n) => n !== node).length === 0;\n  }\n  if (name === 'first-child') {\n    const { rendered } = findParentNode(root, node);\n    const [firstChild] = rendered;\n    return firstChild === node;\n  }\n  if (name === 'last-child') {\n    const { rendered } = findParentNode(root, node);\n    return rendered[rendered.length - 1] === node;\n  }\n  if (name === 'focus') {\n    if (typeof document === 'undefined') {\n      throw new Error('Enzyme::Selector does not support the \":focus\" pseudo-element without a global `document`.');\n    }\n    const adapter = getAdapter();\n    /* eslint-env browser */\n    return document.activeElement && adapter.nodeToHostNode(node) === document.activeElement;\n  }\n\n  throw new TypeError(`Enzyme::Selector does not support the \"${token.name}\" pseudo-element or pseudo-class selectors.`);\n}\n\n/**\n * Takes a node and a token and determines if the node\n * matches the predicate defined by the token.\n * @param {Node} node\n * @param {Token} token\n */\nfunction nodeMatchesToken(node, token, root) {\n  if (node === null || typeof node === 'string') {\n    return false;\n  }\n  switch (token.type) {\n    /**\n     * Match every node\n     * @example '*' matches every node\n     */\n    case UNIVERSAL_SELECTOR:\n      return true;\n    /**\n     * Match against the className prop\n     * @example '.active' matches <div className='active' />\n     */\n    case CLASS_SELECTOR:\n      return hasClassName(node, token.name);\n    /**\n     * Simple type matching\n     * @example 'div' matches <div />\n     */\n    case TYPE_SELECTOR:\n      return nodeHasType(node, token.name);\n    /**\n     * Match against the `id` prop\n     * @example '#nav' matches <ul id=\"nav\" />\n     */\n    case ID_SELECTOR:\n      return nodeHasId(node, token.name);\n    /**\n     * Matches if an attribute is present, regardless\n     * of its value\n     * @example '[disabled]' matches <a disabled />\n     */\n    case ATTRIBUTE_PRESENCE:\n      return matchAttributeSelector(node, token);\n    /**\n     * Matches if an attribute is present with the\n     * provided value\n     * @example '[data-foo=foo]' matches <div data-foo=\"foo\" />\n     */\n    case ATTRIBUTE_VALUE:\n      return matchAttributeSelector(node, token);\n    case PSEUDO_ELEMENT:\n    case PSEUDO_CLASS:\n      return matchPseudoSelector(node, token, root);\n    default:\n      throw new Error(`Unknown token type: ${token.type}`);\n  }\n}\n\n/**\n * Returns a predicate function that checks if a\n * node matches every token in the body of a selector\n * token.\n * @param {Token} token\n */\nfunction buildPredicateFromToken(token, root) {\n  return (node) => token.body.every((bodyToken) => nodeMatchesToken(node, bodyToken, root));\n}\n\n/**\n * Returns whether a parsed selector is a complex selector, which\n * is defined as a selector that contains combinators.\n * @param {Array<Token>} tokens\n */\nfunction isComplexSelector(tokens) {\n  return tokens.some((token) => token.type !== SELECTOR);\n}\n\n\n/**\n * Takes a component constructor, object, or string representing\n * a simple selector and returns a predicate function that can\n * be applied to a single node.\n * @param {EnzymeSelector} selector\n */\nexport function buildPredicate(selector) {\n  // If the selector is a string, parse it as a simple CSS selector\n  if (typeof selector === 'string') {\n    const tokens = safelyGenerateTokens(selector);\n    if (isComplexSelector(tokens)) {\n      throw new TypeError('This method does not support complex CSS selectors');\n    }\n    // Simple selectors only have a single selector token\n    return buildPredicateFromToken(tokens[0]);\n  }\n\n  // If the selector is an element type, check if the node's type matches\n  const adapter = getAdapter();\n  const isElementType = adapter.isValidElementType\n    ? adapter.isValidElementType(selector)\n    : typeof selector === 'function';\n  if (isElementType) {\n    return (node) => adapter.matchesElementType(node, selector);\n  }\n  // If the selector is an non-empty object, treat the keys/values as props\n  if (typeof selector === 'object') {\n    if (!Array.isArray(selector) && selector !== null && Object.keys(selector).length > 0) {\n      const hasUndefinedValues = values(selector).some((value) => typeof value === 'undefined');\n      if (hasUndefinedValues) {\n        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');\n      }\n      return (node) => nodeMatchesObjectProps(node, selector);\n    }\n    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');\n  }\n\n  throw new TypeError('Enzyme::Selector expects a string, object, or valid element type (Component Constructor)');\n}\n\n/**\n * Matches only nodes which are adjacent siblings (direct next sibling)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchAdjacentSiblings(nodes, predicate, root) {\n  return nodes.reduce((matches, node) => {\n    const parent = findParentNode(root, node);\n    // If there's no parent, there's no siblings\n    if (!parent) {\n      return matches;\n    }\n    const parentChildren = childrenOfNode(parent);\n    const nodeIndex = parentChildren.indexOf(node);\n    const adjacentSibling = parentChildren[nodeIndex + 1];\n    // No sibling\n    if (!adjacentSibling) {\n      return matches;\n    }\n    if (predicate(adjacentSibling)) {\n      matches.push(adjacentSibling);\n    }\n    return matches;\n  }, []);\n}\n\n/**\n * Matches only nodes which are general siblings (any sibling *after*)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchGeneralSibling(nodes, predicate, root) {\n  return uniqueReduce((matches, node) => {\n    const parent = findParentNode(root, node);\n    if (!parent) {\n      return matches;\n    }\n    const parentChildren = childrenOfNode(parent);\n    const nodeIndex = parentChildren.indexOf(node);\n    const youngerSiblings = parentChildren.slice(nodeIndex + 1);\n    return matches.concat(youngerSiblings.filter(predicate));\n  }, nodes);\n}\n\n/**\n * Matches only nodes which are direct children (not grandchildren, etc.)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDirectChild(nodes, predicate) {\n  return uniqueReduce(\n    (matches, node) => matches.concat(childrenOfNode(node).filter(predicate)),\n    nodes,\n  );\n}\n\n/**\n * Matches all descendant nodes against a predicate,\n * returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDescendant(nodes, predicate) {\n  return uniqueReduce(\n    (matches, node) => matches.concat(treeFilter(node, predicate)),\n    flat(nodes.map(childrenOfNode)),\n  );\n}\n\n/**\n * Takes an RST and reduces it to a set of nodes matching\n * the selector. The selector can be a simple selector, which\n * is handled by `buildPredicate`, or a complex CSS selector which\n * reduceTreeBySelector parses and reduces the tree based on the combinators.\n *\n * @param {EnzymeSelector} selector\n * @param {RSTNode} root\n */\nexport function reduceTreeBySelector(selector, root) {\n  if (typeof selector !== 'string') {\n    const elements = elementsByConstructor(selector);\n    if (elements.length > 0) {\n      return flat(elements.map((x) => reduceTreeBySelector(x.tag, root)));\n\n      // when https://github.com/aweary/rst-selector-parser/issues/15 is resolved\n      // const htmlTagNames = elements.map(x => x.tag).join(', ');\n      // return reduceTreeBySelector(htmlTagNames, root);\n    }\n  }\n\n  if (typeof selector === 'function' || typeof selector === 'object') {\n    return treeFilter(root, buildPredicate(selector));\n  }\n\n  let results = [];\n  if (typeof selector === 'string') {\n    const tokens = safelyGenerateTokens(selector);\n    let index = 0;\n    while (index < tokens.length) {\n      const token = tokens[index];\n      /**\n       * There are two types of tokens in a CSS selector:\n       *\n       * 1. Selector tokens. These target nodes directly, like\n       *    type or attribute selectors. These are easy to apply\n       *    because we can traverse the tree and return only\n       *    the nodes that match the predicate.\n       *\n       * 2. Combinator tokens. These tokens chain together\n       *    selector nodes. For example > for children, or +\n       *    for adjacent siblings. These are harder to match\n       *    as we have to track where in the tree we are\n       *    to determine if a selector node applies or not.\n       */\n      if (token.type === SELECTOR) {\n        const predicate = buildPredicateFromToken(token, root);\n        results = results.concat(treeFilter(root, predicate));\n      } else {\n        // We can assume there always all previously matched tokens since selectors\n        // cannot start with combinators.\n        const { type } = token;\n        // We assume the next token is a selector, so move the index\n        // forward and build the predicate.\n        index += 1;\n        const predicate = buildPredicateFromToken(tokens[index], root);\n        // We match against only the nodes which have already been matched,\n        // since a combinator is meant to refine a previous selector.\n        switch (type) {\n          // The + combinator\n          case ADJACENT_SIBLING:\n            results = matchAdjacentSiblings(results, predicate, root);\n            break;\n          // The ~ combinator\n          case GENERAL_SIBLING:\n            results = matchGeneralSibling(results, predicate, root);\n            break;\n          // The > combinator\n          case CHILD:\n            results = matchDirectChild(results, predicate);\n            break;\n          // The ' ' (whitespace) combinator\n          case DESCENDANT: {\n            results = matchDescendant(results, predicate);\n            break;\n          }\n          default:\n            throw new Error(`Unknown combinator selector: ${type}`);\n        }\n      }\n      index += 1;\n    }\n  } else {\n    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');\n  }\n  return results;\n}\n\nexport function reduceTreesBySelector(selector, roots) {\n  const results = roots.map((n) => reduceTreeBySelector(selector, n));\n  return unique(flat(results, 1));\n}\n"]},"metadata":{},"sourceType":"script"}