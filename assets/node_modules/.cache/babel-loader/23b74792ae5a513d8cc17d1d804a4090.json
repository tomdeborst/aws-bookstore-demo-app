{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapNativeEventNames = mapNativeEventNames;\nexports.propFromEvent = propFromEvent;\nexports.withSetStateAllowed = withSetStateAllowed;\nexports.assertDomAvailable = assertDomAvailable;\nexports.displayNameOfNode = displayNameOfNode;\nexports.nodeTypeFromType = nodeTypeFromType;\nexports.isArrayLike = isArrayLike;\nexports.flatten = flatten;\nexports.ensureKeyOrUndefined = ensureKeyOrUndefined;\nexports.elementToTree = elementToTree;\nexports.findElement = findElement;\nexports.propsWithKeysAndRef = propsWithKeysAndRef;\nexports.getComponentStack = getComponentStack;\nexports.simulateError = simulateError;\nexports.getMaskedContext = getMaskedContext;\nexports.getNodeFromRootFinder = getNodeFromRootFinder;\nexports.wrapWithWrappingComponent = wrapWithWrappingComponent;\nexports.getWrappingComponentMountRenderer = getWrappingComponentMountRenderer;\nexports.fakeDynamicImport = fakeDynamicImport;\nexports.compareNodeTypeOf = compareNodeTypeOf;\nexports.spyMethod = spyMethod;\nexports.spyProperty = spyProperty;\nObject.defineProperty(exports, \"createMountWrapper\", {\n  enumerable: true,\n  get: function get() {\n    return _createMountWrapper[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"createRenderWrapper\", {\n  enumerable: true,\n  get: function get() {\n    return _createRenderWrapper[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"wrap\", {\n  enumerable: true,\n  get: function get() {\n    return _wrapWithSimpleWrapper[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"RootFinder\", {\n  enumerable: true,\n  get: function get() {\n    return _RootFinder[\"default\"];\n  }\n});\n\nvar _functionPrototype = _interopRequireDefault(require(\"function.prototype.name\"));\n\nvar _object = _interopRequireDefault(require(\"object.fromentries\"));\n\nvar _has = _interopRequireDefault(require(\"has\"));\n\nvar _createMountWrapper = _interopRequireDefault(require(\"./createMountWrapper\"));\n\nvar _createRenderWrapper = _interopRequireDefault(require(\"./createRenderWrapper\"));\n\nvar _wrapWithSimpleWrapper = _interopRequireDefault(require(\"./wrapWithSimpleWrapper\"));\n\nvar _RootFinder = _interopRequireDefault(require(\"./RootFinder\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction mapNativeEventNames(event) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$animation = _ref.animation,\n      animation = _ref$animation === void 0 ? false : _ref$animation,\n      _ref$pointerEvents = _ref.pointerEvents,\n      pointerEvents = _ref$pointerEvents === void 0 ? false : _ref$pointerEvents,\n      _ref$auxClick = _ref.auxClick,\n      auxClick = _ref$auxClick === void 0 ? false : _ref$auxClick;\n\n  var nativeToReactEventMap = _objectSpread(_objectSpread(_objectSpread({\n    compositionend: 'compositionEnd',\n    compositionstart: 'compositionStart',\n    compositionupdate: 'compositionUpdate',\n    keydown: 'keyDown',\n    keyup: 'keyUp',\n    keypress: 'keyPress',\n    contextmenu: 'contextMenu',\n    dblclick: 'doubleClick',\n    doubleclick: 'doubleClick',\n    // kept for legacy. TODO: remove with next major.\n    dragend: 'dragEnd',\n    dragenter: 'dragEnter',\n    dragexist: 'dragExit',\n    dragleave: 'dragLeave',\n    dragover: 'dragOver',\n    dragstart: 'dragStart',\n    mousedown: 'mouseDown',\n    mousemove: 'mouseMove',\n    mouseout: 'mouseOut',\n    mouseover: 'mouseOver',\n    mouseup: 'mouseUp',\n    touchcancel: 'touchCancel',\n    touchend: 'touchEnd',\n    touchmove: 'touchMove',\n    touchstart: 'touchStart',\n    canplay: 'canPlay',\n    canplaythrough: 'canPlayThrough',\n    durationchange: 'durationChange',\n    loadeddata: 'loadedData',\n    loadedmetadata: 'loadedMetadata',\n    loadstart: 'loadStart',\n    ratechange: 'rateChange',\n    timeupdate: 'timeUpdate',\n    volumechange: 'volumeChange',\n    beforeinput: 'beforeInput',\n    mouseenter: 'mouseEnter',\n    mouseleave: 'mouseLeave',\n    transitionend: 'transitionEnd'\n  }, animation && {\n    animationstart: 'animationStart',\n    animationiteration: 'animationIteration',\n    animationend: 'animationEnd'\n  }), pointerEvents && {\n    pointerdown: 'pointerDown',\n    pointermove: 'pointerMove',\n    pointerup: 'pointerUp',\n    pointercancel: 'pointerCancel',\n    gotpointercapture: 'gotPointerCapture',\n    lostpointercapture: 'lostPointerCapture',\n    pointerenter: 'pointerEnter',\n    pointerleave: 'pointerLeave',\n    pointerover: 'pointerOver',\n    pointerout: 'pointerOut'\n  }), auxClick && {\n    auxclick: 'auxClick'\n  });\n\n  return nativeToReactEventMap[event] || event;\n} // 'click' => 'onClick'\n// 'mouseEnter' => 'onMouseEnter'\n\n\nfunction propFromEvent(event) {\n  var eventOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var nativeEvent = mapNativeEventNames(event, eventOptions);\n  return \"on\".concat(nativeEvent[0].toUpperCase()).concat(nativeEvent.slice(1));\n}\n\nfunction withSetStateAllowed(fn) {\n  // NOTE(lmr):\n  // this is currently here to circumvent a React bug where `setState()` is\n  // not allowed without global being defined.\n  var cleanup = false;\n\n  if (typeof global.document === 'undefined') {\n    cleanup = true;\n    global.document = {};\n  }\n\n  var result = fn();\n\n  if (cleanup) {\n    // This works around a bug in node/jest in that developers aren't able to\n    // delete things from global when running in a node vm.\n    global.document = undefined;\n    delete global.document;\n  }\n\n  return result;\n}\n\nfunction assertDomAvailable(feature) {\n  if (!global || !global.document || !global.document.createElement) {\n    throw new Error(\"Enzyme's \".concat(feature, \" expects a DOM environment to be loaded, but found none\"));\n  }\n}\n\nfunction displayNameOfNode(node) {\n  if (!node) return null;\n  var type = node.type;\n  if (!type) return null;\n  return type.displayName || (typeof type === 'function' ? (0, _functionPrototype[\"default\"])(type) : type.name || type);\n}\n\nfunction nodeTypeFromType(type) {\n  if (typeof type === 'string') {\n    return 'host';\n  }\n\n  if (type && type.prototype && type.prototype.isReactComponent) {\n    return 'class';\n  }\n\n  return 'function';\n}\n\nfunction getIteratorFn(obj) {\n  var iteratorFn = obj && (typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol' && obj[Symbol.iterator] || obj['@@iterator']);\n\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n\n  return undefined;\n}\n\nfunction isIterable(obj) {\n  return !!getIteratorFn(obj);\n}\n\nfunction isArrayLike(obj) {\n  return Array.isArray(obj) || typeof obj !== 'string' && isIterable(obj);\n}\n\nfunction flatten(arrs) {\n  // optimize for the most common case\n  if (Array.isArray(arrs)) {\n    return arrs.reduce(function (flatArrs, item) {\n      return flatArrs.concat(isArrayLike(item) ? flatten(item) : item);\n    }, []);\n  } // fallback for arbitrary iterable children\n\n\n  var flatArrs = [];\n  var iteratorFn = getIteratorFn(arrs);\n  var iterator = iteratorFn.call(arrs);\n  var step = iterator.next();\n\n  while (!step.done) {\n    var item = step.value;\n    var flatItem = void 0;\n\n    if (isArrayLike(item)) {\n      flatItem = flatten(item);\n    } else {\n      flatItem = item;\n    }\n\n    flatArrs = flatArrs.concat(flatItem);\n    step = iterator.next();\n  }\n\n  return flatArrs;\n}\n\nfunction ensureKeyOrUndefined(key) {\n  return key || (key === '' ? '' : undefined);\n}\n\nfunction elementToTree(el) {\n  var recurse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : elementToTree;\n\n  if (typeof recurse !== 'function' && arguments.length === 3) {\n    // special case for backwards compat for `.map(elementToTree)`\n    recurse = elementToTree; // eslint-disable-line no-param-reassign\n  }\n\n  if (el === null || _typeof(el) !== 'object' || !('type' in el)) {\n    return el;\n  }\n\n  var type = el.type,\n      props = el.props,\n      key = el.key,\n      ref = el.ref;\n  var children = props.children;\n  var rendered = null;\n\n  if (isArrayLike(children)) {\n    rendered = flatten(children).map(function (x) {\n      return recurse(x);\n    });\n  } else if (typeof children !== 'undefined') {\n    rendered = recurse(children);\n  }\n\n  var nodeType = nodeTypeFromType(type);\n\n  if (nodeType === 'host' && props.dangerouslySetInnerHTML) {\n    if (props.children != null) {\n      var error = new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');\n      error.name = 'Invariant Violation';\n      throw error;\n    }\n  }\n\n  return {\n    nodeType: nodeType,\n    type: type,\n    props: props,\n    key: ensureKeyOrUndefined(key),\n    ref: ref,\n    instance: null,\n    rendered: rendered\n  };\n}\n\nfunction mapFind(arraylike, mapper, finder) {\n  var found;\n  var isFound = Array.prototype.find.call(arraylike, function (item) {\n    found = mapper(item);\n    return finder(found);\n  });\n  return isFound ? found : undefined;\n}\n\nfunction findElement(el, predicate) {\n  if (el === null || _typeof(el) !== 'object' || !('type' in el)) {\n    return undefined;\n  }\n\n  if (predicate(el)) {\n    return el;\n  }\n\n  var rendered = el.rendered;\n\n  if (isArrayLike(rendered)) {\n    return mapFind(rendered, function (x) {\n      return findElement(x, predicate);\n    }, function (x) {\n      return typeof x !== 'undefined';\n    });\n  }\n\n  return findElement(rendered, predicate);\n}\n\nfunction propsWithKeysAndRef(node) {\n  if (node.ref !== null || node.key !== null) {\n    return _objectSpread(_objectSpread({}, node.props), {}, {\n      key: node.key,\n      ref: node.ref\n    });\n  }\n\n  return node.props;\n}\n\nfunction getComponentStack(hierarchy) {\n  var getNodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : nodeTypeFromType;\n  var getDisplayName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : displayNameOfNode;\n  var tuples = hierarchy.filter(function (node) {\n    return node.type !== _RootFinder[\"default\"];\n  }).map(function (x) {\n    return [getNodeType(x.type), getDisplayName(x)];\n  }).concat([['class', 'WrapperComponent']]);\n  return tuples.map(function (_ref2, i, arr) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        name = _ref3[1];\n\n    var _ref4 = arr.slice(i + 1).find(function (_ref6) {\n      var _ref7 = _slicedToArray(_ref6, 1),\n          nodeType = _ref7[0];\n\n      return nodeType !== 'host';\n    }) || [],\n        _ref5 = _slicedToArray(_ref4, 2),\n        closestComponent = _ref5[1];\n\n    return \"\\n    in \".concat(name).concat(closestComponent ? \" (created by \".concat(closestComponent, \")\") : '');\n  }).join('');\n}\n\nfunction simulateError(error, catchingInstance, rootNode, // TODO: remove `rootNode` next semver-major\nhierarchy) {\n  var getNodeType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : nodeTypeFromType;\n  var getDisplayName = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : displayNameOfNode;\n  var catchingType = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n  var instance = catchingInstance || {};\n  var componentDidCatch = instance.componentDidCatch;\n  var getDerivedStateFromError = catchingType.getDerivedStateFromError;\n\n  if (!componentDidCatch && !getDerivedStateFromError) {\n    throw error;\n  }\n\n  if (getDerivedStateFromError) {\n    var stateUpdate = getDerivedStateFromError.call(catchingType, error);\n    instance.setState(stateUpdate);\n  }\n\n  if (componentDidCatch) {\n    var componentStack = getComponentStack(hierarchy, getNodeType, getDisplayName);\n    componentDidCatch.call(instance, error, {\n      componentStack: componentStack\n    });\n  }\n}\n\nfunction getMaskedContext(contextTypes, unmaskedContext) {\n  if (!contextTypes || !unmaskedContext) {\n    return {};\n  }\n\n  return (0, _object[\"default\"])(Object.keys(contextTypes).map(function (key) {\n    return [key, unmaskedContext[key]];\n  }));\n}\n\nfunction getNodeFromRootFinder(isCustomComponent, tree, options) {\n  if (!isCustomComponent(options.wrappingComponent)) {\n    return tree.rendered;\n  }\n\n  var rootFinder = findElement(tree, function (node) {\n    return node.type === _RootFinder[\"default\"];\n  });\n\n  if (!rootFinder) {\n    throw new Error('`wrappingComponent` must render its children!');\n  }\n\n  return rootFinder.rendered;\n}\n\nfunction wrapWithWrappingComponent(createElement, node, options) {\n  var wrappingComponent = options.wrappingComponent,\n      wrappingComponentProps = options.wrappingComponentProps;\n\n  if (!wrappingComponent) {\n    return node;\n  }\n\n  return createElement(wrappingComponent, wrappingComponentProps, createElement(_RootFinder[\"default\"], null, node));\n}\n\nfunction getWrappingComponentMountRenderer(_ref8) {\n  var toTree = _ref8.toTree,\n      getMountWrapperInstance = _ref8.getMountWrapperInstance;\n  return {\n    getNode: function getNode() {\n      var instance = getMountWrapperInstance();\n      return instance ? toTree(instance).rendered : null;\n    },\n    render: function render(el, context, callback) {\n      var instance = getMountWrapperInstance();\n\n      if (!instance) {\n        throw new Error('The wrapping component may not be updated if the root is unmounted.');\n      }\n\n      return instance.setWrappingComponentProps(el.props, callback);\n    }\n  };\n}\n\nfunction fakeDynamicImport(moduleToImport) {\n  return Promise.resolve({\n    \"default\": moduleToImport\n  });\n}\n\nfunction compareNodeTypeOf(node, matchingTypeOf) {\n  if (!node) {\n    return false;\n  }\n\n  return node.$$typeof === matchingTypeOf;\n} // TODO: when enzyme v3.12.0 is required, delete this\n\n\nfunction spyMethod(instance, methodName) {\n  var getStub = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n  var lastReturnValue;\n  var originalMethod = instance[methodName];\n  var hasOwn = (0, _has[\"default\"])(instance, methodName);\n  var descriptor;\n\n  if (hasOwn) {\n    descriptor = Object.getOwnPropertyDescriptor(instance, methodName);\n  }\n\n  Object.defineProperty(instance, methodName, {\n    configurable: true,\n    enumerable: !descriptor || !!descriptor.enumerable,\n    value: getStub(originalMethod) || function spied() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var result = originalMethod.apply(this, args);\n      lastReturnValue = result;\n      return result;\n    }\n  });\n  return {\n    restore: function restore() {\n      if (hasOwn) {\n        if (descriptor) {\n          Object.defineProperty(instance, methodName, descriptor);\n        } else {\n          /* eslint-disable no-param-reassign */\n          instance[methodName] = originalMethod;\n          /* eslint-enable no-param-reassign */\n        }\n      } else {\n        /* eslint-disable no-param-reassign */\n        delete instance[methodName];\n        /* eslint-enable no-param-reassign */\n      }\n    },\n    getLastReturnValue: function getLastReturnValue() {\n      return lastReturnValue;\n    }\n  };\n} // TODO: when enzyme v3.12.0 is required, delete this\n\n\nfunction spyProperty(instance, propertyName) {\n  var handlers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var originalValue = instance[propertyName];\n  var hasOwn = (0, _has[\"default\"])(instance, propertyName);\n  var descriptor;\n\n  if (hasOwn) {\n    descriptor = Object.getOwnPropertyDescriptor(instance, propertyName);\n  }\n\n  var _wasAssigned = false;\n  var holder = originalValue;\n  var getV = handlers.get ? function () {\n    var value = descriptor && descriptor.get ? descriptor.get.call(instance) : holder;\n    return handlers.get.call(instance, value);\n  } : function () {\n    return holder;\n  };\n  var set = handlers.set ? function (newValue) {\n    _wasAssigned = true;\n    var handlerNewValue = handlers.set.call(instance, holder, newValue);\n    holder = handlerNewValue;\n\n    if (descriptor && descriptor.set) {\n      descriptor.set.call(instance, holder);\n    }\n  } : function (v) {\n    _wasAssigned = true;\n    holder = v;\n  };\n  Object.defineProperty(instance, propertyName, {\n    configurable: true,\n    enumerable: !descriptor || !!descriptor.enumerable,\n    get: getV,\n    set: set\n  });\n  return {\n    restore: function restore() {\n      if (hasOwn) {\n        if (descriptor) {\n          Object.defineProperty(instance, propertyName, descriptor);\n        } else {\n          /* eslint-disable no-param-reassign */\n          instance[propertyName] = holder;\n          /* eslint-enable no-param-reassign */\n        }\n      } else {\n        /* eslint-disable no-param-reassign */\n        delete instance[propertyName];\n        /* eslint-enable no-param-reassign */\n      }\n    },\n    wasAssigned: function wasAssigned() {\n      return _wasAssigned;\n    }\n  };\n} //# sourceMappingURL=Utils.js.map","map":{"version":3,"sources":["../src/Utils.js"],"names":["animation","pointerEvents","auxClick","nativeToReactEventMap","compositionend","compositionstart","compositionupdate","keydown","keyup","keypress","contextmenu","dblclick","doubleclick","dragend","dragenter","dragexist","dragleave","dragover","dragstart","mousedown","mousemove","mouseout","mouseover","mouseup","touchcancel","touchend","touchmove","touchstart","canplay","canplaythrough","durationchange","loadeddata","loadedmetadata","loadstart","ratechange","timeupdate","volumechange","beforeinput","mouseenter","mouseleave","transitionend","animationstart","animationiteration","animationend","pointerdown","pointermove","pointerup","pointercancel","gotpointercapture","lostpointercapture","pointerenter","pointerleave","pointerover","pointerout","auxclick","eventOptions","nativeEvent","mapNativeEventNames","cleanup","global","result","fn","type","node","iteratorFn","obj","Symbol","getIteratorFn","Array","isIterable","flatArrs","isArrayLike","flatten","iterator","step","item","flatItem","key","recurse","elementToTree","arguments","el","props","ref","children","rendered","nodeType","nodeTypeFromType","error","ensureKeyOrUndefined","instance","isFound","found","mapper","finder","predicate","mapFind","findElement","getNodeType","getDisplayName","displayNameOfNode","tuples","RootFinder","x","name","closestComponent","i","catchingType","catchingInstance","componentDidCatch","getDerivedStateFromError","stateUpdate","componentStack","getComponentStack","unmaskedContext","isCustomComponent","options","tree","rootFinder","wrappingComponent","wrappingComponentProps","createElement","toTree","getMountWrapperInstance","getNode","render","moduleToImport","getStub","originalMethod","hasOwn","descriptor","Object","configurable","enumerable","value","args","lastReturnValue","restore","getLastReturnValue","handlers","originalValue","wasAssigned","holder","getV","set","handlerNewValue","get"],"mappings":"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","sourcesContent":["import functionName from 'function.prototype.name';\nimport fromEntries from 'object.fromentries';\nimport has from 'has';\nimport createMountWrapper from './createMountWrapper';\nimport createRenderWrapper from './createRenderWrapper';\nimport wrap from './wrapWithSimpleWrapper';\nimport RootFinder from './RootFinder';\n\nexport {\n  createMountWrapper,\n  createRenderWrapper,\n  wrap,\n  RootFinder,\n};\n\nexport function mapNativeEventNames(event, {\n  animation = false, // should be true for React 15+\n  pointerEvents = false, // should be true for React 16.4+\n  auxClick = false, // should be true for React 16.5+\n} = {}) {\n  const nativeToReactEventMap = {\n    compositionend: 'compositionEnd',\n    compositionstart: 'compositionStart',\n    compositionupdate: 'compositionUpdate',\n    keydown: 'keyDown',\n    keyup: 'keyUp',\n    keypress: 'keyPress',\n    contextmenu: 'contextMenu',\n    dblclick: 'doubleClick',\n    doubleclick: 'doubleClick', // kept for legacy. TODO: remove with next major.\n    dragend: 'dragEnd',\n    dragenter: 'dragEnter',\n    dragexist: 'dragExit',\n    dragleave: 'dragLeave',\n    dragover: 'dragOver',\n    dragstart: 'dragStart',\n    mousedown: 'mouseDown',\n    mousemove: 'mouseMove',\n    mouseout: 'mouseOut',\n    mouseover: 'mouseOver',\n    mouseup: 'mouseUp',\n    touchcancel: 'touchCancel',\n    touchend: 'touchEnd',\n    touchmove: 'touchMove',\n    touchstart: 'touchStart',\n    canplay: 'canPlay',\n    canplaythrough: 'canPlayThrough',\n    durationchange: 'durationChange',\n    loadeddata: 'loadedData',\n    loadedmetadata: 'loadedMetadata',\n    loadstart: 'loadStart',\n    ratechange: 'rateChange',\n    timeupdate: 'timeUpdate',\n    volumechange: 'volumeChange',\n    beforeinput: 'beforeInput',\n    mouseenter: 'mouseEnter',\n    mouseleave: 'mouseLeave',\n    transitionend: 'transitionEnd',\n    ...(animation && {\n      animationstart: 'animationStart',\n      animationiteration: 'animationIteration',\n      animationend: 'animationEnd',\n    }),\n    ...(pointerEvents && {\n      pointerdown: 'pointerDown',\n      pointermove: 'pointerMove',\n      pointerup: 'pointerUp',\n      pointercancel: 'pointerCancel',\n      gotpointercapture: 'gotPointerCapture',\n      lostpointercapture: 'lostPointerCapture',\n      pointerenter: 'pointerEnter',\n      pointerleave: 'pointerLeave',\n      pointerover: 'pointerOver',\n      pointerout: 'pointerOut',\n    }),\n    ...(auxClick && {\n      auxclick: 'auxClick',\n    }),\n  };\n\n  return nativeToReactEventMap[event] || event;\n}\n\n// 'click' => 'onClick'\n// 'mouseEnter' => 'onMouseEnter'\nexport function propFromEvent(event, eventOptions = {}) {\n  const nativeEvent = mapNativeEventNames(event, eventOptions);\n  return `on${nativeEvent[0].toUpperCase()}${nativeEvent.slice(1)}`;\n}\n\nexport function withSetStateAllowed(fn) {\n  // NOTE(lmr):\n  // this is currently here to circumvent a React bug where `setState()` is\n  // not allowed without global being defined.\n  let cleanup = false;\n  if (typeof global.document === 'undefined') {\n    cleanup = true;\n    global.document = {};\n  }\n  const result = fn();\n  if (cleanup) {\n    // This works around a bug in node/jest in that developers aren't able to\n    // delete things from global when running in a node vm.\n    global.document = undefined;\n    delete global.document;\n  }\n  return result;\n}\n\nexport function assertDomAvailable(feature) {\n  if (!global || !global.document || !global.document.createElement) {\n    throw new Error(`Enzyme's ${feature} expects a DOM environment to be loaded, but found none`);\n  }\n}\n\nexport function displayNameOfNode(node) {\n  if (!node) return null;\n\n  const { type } = node;\n\n  if (!type) return null;\n\n  return type.displayName || (typeof type === 'function' ? functionName(type) : type.name || type);\n}\n\nexport function nodeTypeFromType(type) {\n  if (typeof type === 'string') {\n    return 'host';\n  }\n  if (type && type.prototype && type.prototype.isReactComponent) {\n    return 'class';\n  }\n  return 'function';\n}\n\nfunction getIteratorFn(obj) {\n  const iteratorFn = obj && (\n    (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' && obj[Symbol.iterator])\n    || obj['@@iterator']\n  );\n\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n\n  return undefined;\n}\n\nfunction isIterable(obj) {\n  return !!getIteratorFn(obj);\n}\n\nexport function isArrayLike(obj) {\n  return Array.isArray(obj) || (typeof obj !== 'string' && isIterable(obj));\n}\n\nexport function flatten(arrs) {\n  // optimize for the most common case\n  if (Array.isArray(arrs)) {\n    return arrs.reduce(\n      (flatArrs, item) => flatArrs.concat(isArrayLike(item) ? flatten(item) : item),\n      [],\n    );\n  }\n\n  // fallback for arbitrary iterable children\n  let flatArrs = [];\n\n  const iteratorFn = getIteratorFn(arrs);\n  const iterator = iteratorFn.call(arrs);\n\n  let step = iterator.next();\n\n  while (!step.done) {\n    const item = step.value;\n    let flatItem;\n\n    if (isArrayLike(item)) {\n      flatItem = flatten(item);\n    } else {\n      flatItem = item;\n    }\n\n    flatArrs = flatArrs.concat(flatItem);\n\n    step = iterator.next();\n  }\n\n  return flatArrs;\n}\n\nexport function ensureKeyOrUndefined(key) {\n  return key || (key === '' ? '' : undefined);\n}\n\nexport function elementToTree(el, recurse = elementToTree) {\n  if (typeof recurse !== 'function' && arguments.length === 3) {\n    // special case for backwards compat for `.map(elementToTree)`\n    recurse = elementToTree; // eslint-disable-line no-param-reassign\n  }\n  if (el === null || typeof el !== 'object' || !('type' in el)) {\n    return el;\n  }\n  const {\n    type,\n    props,\n    key,\n    ref,\n  } = el;\n  const { children } = props;\n  let rendered = null;\n  if (isArrayLike(children)) {\n    rendered = flatten(children).map((x) => recurse(x));\n  } else if (typeof children !== 'undefined') {\n    rendered = recurse(children);\n  }\n\n  const nodeType = nodeTypeFromType(type);\n\n  if (nodeType === 'host' && props.dangerouslySetInnerHTML) {\n    if (props.children != null) {\n      const error = new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');\n      error.name = 'Invariant Violation';\n      throw error;\n    }\n  }\n\n  return {\n    nodeType,\n    type,\n    props,\n    key: ensureKeyOrUndefined(key),\n    ref,\n    instance: null,\n    rendered,\n  };\n}\n\nfunction mapFind(arraylike, mapper, finder) {\n  let found;\n  const isFound = Array.prototype.find.call(arraylike, (item) => {\n    found = mapper(item);\n    return finder(found);\n  });\n  return isFound ? found : undefined;\n}\n\nexport function findElement(el, predicate) {\n  if (el === null || typeof el !== 'object' || !('type' in el)) {\n    return undefined;\n  }\n  if (predicate(el)) {\n    return el;\n  }\n  const { rendered } = el;\n  if (isArrayLike(rendered)) {\n    return mapFind(rendered, (x) => findElement(x, predicate), (x) => typeof x !== 'undefined');\n  }\n  return findElement(rendered, predicate);\n}\n\nexport function propsWithKeysAndRef(node) {\n  if (node.ref !== null || node.key !== null) {\n    return {\n      ...node.props,\n      key: node.key,\n      ref: node.ref,\n    };\n  }\n  return node.props;\n}\n\nexport function getComponentStack(\n  hierarchy,\n  getNodeType = nodeTypeFromType,\n  getDisplayName = displayNameOfNode,\n) {\n  const tuples = hierarchy.filter((node) => node.type !== RootFinder).map((x) => [\n    getNodeType(x.type),\n    getDisplayName(x),\n  ]).concat([[\n    'class',\n    'WrapperComponent',\n  ]]);\n\n  return tuples.map(([, name], i, arr) => {\n    const [, closestComponent] = arr.slice(i + 1).find(([nodeType]) => nodeType !== 'host') || [];\n    return `\\n    in ${name}${closestComponent ? ` (created by ${closestComponent})` : ''}`;\n  }).join('');\n}\n\nexport function simulateError(\n  error,\n  catchingInstance,\n  rootNode, // TODO: remove `rootNode` next semver-major\n  hierarchy,\n  getNodeType = nodeTypeFromType,\n  getDisplayName = displayNameOfNode,\n  catchingType = {},\n) {\n  const instance = catchingInstance || {};\n\n  const { componentDidCatch } = instance;\n\n  const { getDerivedStateFromError } = catchingType;\n\n  if (!componentDidCatch && !getDerivedStateFromError) {\n    throw error;\n  }\n\n  if (getDerivedStateFromError) {\n    const stateUpdate = getDerivedStateFromError.call(catchingType, error);\n    instance.setState(stateUpdate);\n  }\n\n  if (componentDidCatch) {\n    const componentStack = getComponentStack(hierarchy, getNodeType, getDisplayName);\n    componentDidCatch.call(instance, error, { componentStack });\n  }\n}\n\nexport function getMaskedContext(contextTypes, unmaskedContext) {\n  if (!contextTypes || !unmaskedContext) {\n    return {};\n  }\n  return fromEntries(Object.keys(contextTypes).map((key) => [key, unmaskedContext[key]]));\n}\n\nexport function getNodeFromRootFinder(isCustomComponent, tree, options) {\n  if (!isCustomComponent(options.wrappingComponent)) {\n    return tree.rendered;\n  }\n  const rootFinder = findElement(tree, (node) => node.type === RootFinder);\n  if (!rootFinder) {\n    throw new Error('`wrappingComponent` must render its children!');\n  }\n  return rootFinder.rendered;\n}\n\nexport function wrapWithWrappingComponent(createElement, node, options) {\n  const { wrappingComponent, wrappingComponentProps } = options;\n  if (!wrappingComponent) {\n    return node;\n  }\n  return createElement(\n    wrappingComponent,\n    wrappingComponentProps,\n    createElement(RootFinder, null, node),\n  );\n}\n\nexport function getWrappingComponentMountRenderer({ toTree, getMountWrapperInstance }) {\n  return {\n    getNode() {\n      const instance = getMountWrapperInstance();\n      return instance ? toTree(instance).rendered : null;\n    },\n    render(el, context, callback) {\n      const instance = getMountWrapperInstance();\n      if (!instance) {\n        throw new Error('The wrapping component may not be updated if the root is unmounted.');\n      }\n      return instance.setWrappingComponentProps(el.props, callback);\n    },\n  };\n}\n\nexport function fakeDynamicImport(moduleToImport) {\n  return Promise.resolve({ default: moduleToImport });\n}\n\nexport function compareNodeTypeOf(node, matchingTypeOf) {\n  if (!node) {\n    return false;\n  }\n  return node.$$typeof === matchingTypeOf;\n}\n\n// TODO: when enzyme v3.12.0 is required, delete this\nexport function spyMethod(instance, methodName, getStub = () => {}) {\n  let lastReturnValue;\n  const originalMethod = instance[methodName];\n  const hasOwn = has(instance, methodName);\n  let descriptor;\n  if (hasOwn) {\n    descriptor = Object.getOwnPropertyDescriptor(instance, methodName);\n  }\n  Object.defineProperty(instance, methodName, {\n    configurable: true,\n    enumerable: !descriptor || !!descriptor.enumerable,\n    value: getStub(originalMethod) || function spied(...args) {\n      const result = originalMethod.apply(this, args);\n      lastReturnValue = result;\n      return result;\n    },\n  });\n  return {\n    restore() {\n      if (hasOwn) {\n        if (descriptor) {\n          Object.defineProperty(instance, methodName, descriptor);\n        } else {\n          /* eslint-disable no-param-reassign */\n          instance[methodName] = originalMethod;\n          /* eslint-enable no-param-reassign */\n        }\n      } else {\n        /* eslint-disable no-param-reassign */\n        delete instance[methodName];\n        /* eslint-enable no-param-reassign */\n      }\n    },\n    getLastReturnValue() {\n      return lastReturnValue;\n    },\n  };\n}\n\n// TODO: when enzyme v3.12.0 is required, delete this\nexport function spyProperty(instance, propertyName, handlers = {}) {\n  const originalValue = instance[propertyName];\n  const hasOwn = has(instance, propertyName);\n  let descriptor;\n  if (hasOwn) {\n    descriptor = Object.getOwnPropertyDescriptor(instance, propertyName);\n  }\n  let wasAssigned = false;\n  let holder = originalValue;\n  const getV = handlers.get ? () => {\n    const value = descriptor && descriptor.get ? descriptor.get.call(instance) : holder;\n    return handlers.get.call(instance, value);\n  } : () => holder;\n  const set = handlers.set ? (newValue) => {\n    wasAssigned = true;\n    const handlerNewValue = handlers.set.call(instance, holder, newValue);\n    holder = handlerNewValue;\n    if (descriptor && descriptor.set) {\n      descriptor.set.call(instance, holder);\n    }\n  } : (v) => {\n    wasAssigned = true;\n    holder = v;\n  };\n  Object.defineProperty(instance, propertyName, {\n    configurable: true,\n    enumerable: !descriptor || !!descriptor.enumerable,\n    get: getV,\n    set,\n  });\n\n  return {\n    restore() {\n      if (hasOwn) {\n        if (descriptor) {\n          Object.defineProperty(instance, propertyName, descriptor);\n        } else {\n          /* eslint-disable no-param-reassign */\n          instance[propertyName] = holder;\n          /* eslint-enable no-param-reassign */\n        }\n      } else {\n        /* eslint-disable no-param-reassign */\n        delete instance[propertyName];\n        /* eslint-enable no-param-reassign */\n      }\n    },\n    wasAssigned() {\n      return wasAssigned;\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"script"}